{% extends 'learning/base.html' %}
{% load static %}
{% load admin_tags %}

{% block title %}{{ module.title }} - Interactive Module{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'css/module-detail.css' %}?v=9">
{% endblock %}

{% block content %}
<div class="module-page">
    <div class="container">
        {% if not is_unlocked %}
        <div class="module-locked-container">
            <div class="lock-message-card">
                <div class="lock-icon">
                    <i class="bi bi-lock-fill"></i>
                </div>
                <h1>Module Locked</h1>
                <p>This module is currently locked. You need to complete the previous module's quiz with a score of 70% or higher to unlock it.</p>
                {% if previous_module %}
                <div class="previous-module-info">
                    <p><strong>Previous Module:</strong> {{ previous_module.title }}</p>
                    {% if is_programming_course %}
                    <a href="{% url 'practice_code' %}?from={{ request.get_full_path|urlencode }}&from_label={{ module.title|urlencode }}" class="practice-button">
                        <i class="bi bi-terminal me-2"></i>Practice Code
                    </a>
                    {% endif %}
                </div>
                {% endif %}
                <a href="{% url 'course_detail' module.course.id %}" class="back-button">
                    <i class="bi bi-arrow-left me-2"></i>Back to Course
                </a>
            </div>
        </div>
        {% else %}
        <div class="module-layout">
            <aside class="module-info">
                <span class="badge bg-gradient px-3 py-2 mb-3" style="background:black !important; border: none;">Module {{ module.order }}</span>
                <h1>{{ module.title }}</h1>
                <p>{{ module.summary }}</p>
                <div class="module-meta">
                    <span><i class="bi bi-journal-bookmark"></i>{{ module.course.title }}</span>
                    <span><i class="bi bi-lightning"></i>Adaptive tutoring</span>
                </div>
                {% if module.learning_objectives %}
                <div class="module-section">
                    <h2>Learning objectives</h2>
                    <ul>
                        {% for item in module.learning_objectives.splitlines %}
                            {% if item.strip %}<li>{{ item }}</li>{% endif %}
                        {% endfor %}
                    </ul>
                </div>
                {% endif %}
                {% if module.topics %}
                <div class="module-section">
                    <h2>Topics covered</h2>
                    <div class="topics-checkbox-list">
                        {% for item in module.topics.splitlines %}
                            {% if item.strip %}
                            {% with topic=item.strip %}
                            <label class="topic-checkbox-item {% if selected_topic == topic %}active{% endif %}">
                                <input type="checkbox" class="topic-checkbox" data-topic="{{ topic }}" value="{{ topic }}" {% if selected_topic == topic %}checked{% endif %}>
                                <span class="topic-checkbox-label">
                                    {{ topic }}
                                    {% with count=topic_chat_counts|get_item:topic %}
                                    {% if count %}
                                    <span class="topic-chat-count">({{ count }})</span>
                                    {% endif %}
                                    {% endwith %}
                                </span>
                            </label>
                            {% endwith %}
                            {% endif %}
                        {% endfor %}
                    </div>
                </div>
                {% endif %}
            </aside>
            <section class="chat-card">
                <div class="chat-header">
                    <div class="d-flex justify-content-between align-items-start">
                        <div>
                            <h2>Interactive tutor</h2>
                            {% if selected_topic %}
                            <p>Teaching: <strong>{{ selected_topic }}</strong> - Ask questions about this topic only.</p>
                            {% else %}
                            <p>Select a topic from the left to start a dedicated chat for that topic.</p>
                            {% endif %}
                        </div>
                        <div class="d-flex gap-2 align-items-center" style="margin-left: 1.5rem;">
                            {% if history %}
                            <button type="button" id="deleteMemoryBtn" class="btn btn-sm" style="background: rgba(220, 38, 38, 0.1); color: #dc2626; border: 1px solid rgba(220, 38, 38, 0.2); padding: 0.4rem 0.8rem; font-size: 0.85rem; border-radius: 12px; transition: all 0.2s ease; font-weight: 600;" title="Delete all conversation history and start fresh">
                                <i class="bi bi-trash me-1"></i>Delete Memory
                            </button>
                            {% endif %}
                            {% if is_programming_course %}
                            <a href="{% url 'practice_code' %}?from={{ request.get_full_path|urlencode }}&from_label={{ module.title|urlencode }}" class="practice-link-btn" style="padding: 0.4rem 0.8rem; font-size: 0.85rem; border-radius: 12px;">
                                <i class="bi bi-terminal me-1"></i>Practice Code
                            </a>
                            {% endif %}
                        </div>
                    </div>
                </div>
                <div class="chat-messages" id="chatMessages">
                    {% if history %}
                        {% for session in history %}
                        <div class="message message-user">
                            <div class="bubble">
                                {{ session.question }}
                            </div>
                        </div>
                        <div class="message message-ai">
                            <div class="bubble">
                                <div class="history-response" data-response="{{ session.response|escape }}"></div>
                            </div>
                        </div>
                        {% endfor %}
                    {% else %}
                    <div class="message message-ai">
                        <div class="bubble">
                            {% if selected_topic %}
                            <strong>Welcome to {{ selected_topic }}!</strong><br><br>
                            This is a dedicated chat for <strong>{{ selected_topic }}</strong> only.<br><br>
                            I'll teach you everything about <strong>{{ selected_topic }}</strong> step by step.<br><br>
                            Use the quick suggestion buttons below or ask your own question to begin.<br><br>
                            <strong>Note:</strong> I will only teach <strong>{{ selected_topic }}</strong> in this chat. I won't discuss other topics here.
                            {% else %}
                            <strong>Welcome to {{ module.title }}!</strong><br><br>
                            <strong>Select a topic from the left sidebar to start a dedicated chat.</strong><br><br>
                            Each topic has its own separate chat where I'll teach only that specific topic.<br><br>
                            <strong>How it works:</strong><br>
                            • Click on any topic checkbox to open its dedicated chat<br>
                            • Each topic chat is isolated - I'll only teach that topic<br>
                            • You can switch between topics anytime by clicking different checkboxes<br>
                            • Each topic maintains its own conversation history
                            {% endif %}
                        </div>
                    </div>
                    {% if selected_topic and not history %}
                    <div class="message message-ai" id="suggestionsMessage">
                        <div class="bubble" style="background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(0, 0, 0, 0.1); padding: 1.25rem;">
                            <div style="font-weight: 600; margin-bottom: 1rem; color: rgba(0, 0, 0, 0.7); font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.05em;">Quick Suggestions</div>
                            <div class="chat-suggestions-buttons" style="display: flex; flex-direction: column; gap: 0.75rem;">
                                {% if is_language_course %}
                                <button type="button" class="chat-suggestion-btn" data-question="Explain {{ selected_topic }} step by step using only this structure for this reply: Overview, Explanation, Sentence Pattern & rules, Usage Examples, Conversation Tip. Keep later answers direct unless I ask again. Avoid programming references.">
                                    Step-by-step breakdown
                                </button>
                                {% else %}
                                <button type="button" class="chat-suggestion-btn" data-question="Explain {{ selected_topic }} step by step using this structure only for this response: Overview, Explanation, Syntax, Example, Real World Example. Keep later answers direct unless I ask again.">
                                    Step-by-step breakdown
                                </button>
                                {% endif %}
                                {% if is_language_course %}
                                <button type="button" class="chat-suggestion-btn" data-question="Share a single everyday scenario that makes {{ selected_topic }} feel natural to use. Focus on how to apply the rule in conversation.">
                                    Real-life context
                                </button>
                                <button type="button" class="chat-suggestion-btn" data-question="Create a mini practice sheet for {{ selected_topic }} with fill-in-the-blank sentences, translation prompts, and a speaking challenge.">
                                    Practice worksheet
                                </button>
                                <button type="button" class="chat-suggestion-btn" data-question="Quiz me with three short grammar questions about {{ selected_topic }}. Ask all questions first and wait for my answers.">
                                    Quiz me on {{ selected_topic }}
                                </button>
                                {% else %}
                                <button type="button" class="chat-suggestion-btn" data-question="Share a single real-world analogy for {{ selected_topic }} that maps each part of the concept to the scenario. Do not re-explain the topic outside the analogy.">
                                    Real-world analogy
                                </button>
                                <button type="button" class="chat-suggestion-btn" data-question="Create an assignment for {{ selected_topic }} with objectives, required steps, and acceptance criteria I can follow.">
                                    Assignment idea
                                </button>
                                <button type="button" class="chat-suggestion-btn" data-question="Quiz me with three questions about {{ selected_topic }}. Ask all questions first and wait for my answers.">
                                    Quiz me on {{ selected_topic }}
                                </button>
                                {% endif %}
                            </div>
                        </div>
                    </div>
                    {% endif %}
                    {% endif %}
                    <div class="typing-indicator" id="typingIndicator">
                        <div class="bubble">
                            <span class="dot"></span><span class="dot"></span><span class="dot"></span>
                        </div>
                    </div>
                </div>
                {% if selected_topic %}
                <div class="chat-input">
                    <form id="moduleChatForm" class="d-grid gap-3">
                        {% csrf_token %}
                        <textarea id="questionInput" placeholder="Ask the tutor about {{ selected_topic }}..." required></textarea>
                        <div class="d-flex justify-content-between align-items-center">
                            <small class="text-muted">
                                <i class="bi bi-lightbulb me-1"></i>Tip: Provide detailed input to get more accurate and helpful answers.
                            </small>
                            <button type="submit" id="sendButton">
                                <i class="bi bi-send-fill me-2"></i>Ask Techietact
                            </button>
                        </div>
                    </form>
                </div>
                {% endif %}
            </section>
        </div>
        {% endif %}
    </div>
</div>

{% endblock %}

{% if is_unlocked %}
{% block extra_js %}
<script>
    const chatMessages = document.getElementById('chatMessages');
    const chatForm = document.getElementById('moduleChatForm');
    const questionInput = document.getElementById('questionInput');
    const sendButton = document.getElementById('sendButton');
    const typingIndicator = document.getElementById('typingIndicator');
    const suggestionButtons = document.querySelectorAll('.chat-suggestion-btn');
    const deleteMemoryBtn = document.getElementById('deleteMemoryBtn');

    // Only initialize chat functionality if input box exists (topic is selected)
    if (!questionInput || !chatForm) {
        // No topic selected, chat input is not available
        console.log('Chat input not available - please select a topic to start chatting');
    }

    function processMarkdown(text) {
        if (!text) return '';
        
        // Remove suggestion markers first (safety check - should already be removed, but ensure it)
        text = removeSuggestionMarkers(text);
        
        const codeBlocks = [];
        let processed = text.replace(/```(\w+)?\n?([\s\S]*?)```/g, (match, lang, code) => {
            codeBlocks.push({ lang: lang || 'plaintext', code: code.trim() });
            return `__CODE_BLOCK_${codeBlocks.length - 1}__`;
        });

        processed = processed.replace(/`([^`]+)`/g, '<code class="inline-code">$1</code>');
        processed = processed.replace(/^#{1,6}\s+(.+)$/gm, '<strong class="ai-heading">$1</strong>');
        // Handle section headers (Real World Example, Explanation, Syntax, Example) with bold and spacing
        processed = processed.replace(/(^|\n)\*\*(Real World Example|Explanation|Syntax|Example)\*\*/gi, '$1<strong style="display: block; margin-top: 1rem; margin-bottom: 0.5rem; font-size: 1.1rem; color: var(--text-primary);">$2</strong>');
        processed = processed.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
        processed = processed.replace(/(?<!•)\*([^*•]+)\*(?!•)/g, '<em>$1</em>');
        processed = processed.replace(/(^|\n)(Topic(?: [^:\n]*)?:)/gi, '$1<strong>$2</strong>');
        processed = processed.replace(/(^|\n)(Sub[\s-]?topic(?: [^:\n]*)?:)/gi, '$1<strong>$2</strong>');
        processed = processed.replace(/(^|\n)(Step\s*\d+:)/gi, '$1<strong>$2</strong>');
        processed = processed.replace(/(^|\n)(Key Takeaways?:)/gi, '$1<strong>$2</strong>');
        processed = processed.replace(/(^|\n)(Next Steps?:)/gi, '$1<strong>$2</strong>');
        processed = processed.replace(/^[\s]*[•\-\*]\s+(.+)$/gm, '<div class="ai-list-item">$1</div>');
        processed = processed.replace(/^\s*\d+\.\s+(.+)$/gm, '<div class="ai-list-item"><strong>$1</strong></div>');
        processed = processed.replace(/\n{3,}/g, '\n\n');
        processed = processed.replace(/\n/g, '<br>');
        processed = processed.replace(/(<div class="ai-list-item">.*?<\/div>)<br>/g, '$1');

        codeBlocks.forEach((block, index) => {
            const escaped = block.code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            const codeHtml = `<div class="code-block-container"><pre class="code-block"><code class="language-${block.lang}">${escaped}</code></pre></div>`;
            processed = processed.replace(`__CODE_BLOCK_${index}__`, codeHtml);
        });

        return processed;
    }

    function scrollToBottom() {
        // Smooth scroll to bottom
        chatMessages.scrollTo({
            top: chatMessages.scrollHeight,
            behavior: 'smooth'
        });
    }

    function scrollToFirstLine(element) {
        // Scroll to show the first line of the element
        if (element && element.offsetTop !== undefined) {
            chatMessages.scrollTo({
                top: element.offsetTop - 20, // Small offset from top
                behavior: 'smooth'
            });
        }
    }

    let currentTypingCallback = null; // Store callback for when typing completes

    function addMessage(text, isUser) {
        const message = document.createElement('div');
        message.className = `message ${isUser ? 'message-user' : 'message-ai'}`;
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        if (isUser) {
            bubble.textContent = text;
            message.appendChild(bubble);
            chatMessages.insertBefore(message, typingIndicator);
            scrollToBottom();
        } else {
            // For AI messages, remove any suggestion markers that might have slipped through
            const cleanedText = removeSuggestionMarkers(text);
            
            // For AI messages, add typing effect
            message.appendChild(bubble);
            chatMessages.insertBefore(message, typingIndicator);
            
            // Process markdown first to get the final HTML
            const finalHTML = processMarkdown(cleanedText);
            
            // Type out the content with typing effect
            // Return a promise that resolves when typing is complete
            return typeMessageWithEffect(bubble, finalHTML, message);
        }
    }

    function typeMessageWithEffect(element, htmlContent, messageElement) {
        // Remove any suggestion markers that might be in the HTML content (safety check)
        htmlContent = removeSuggestionMarkers(htmlContent);
        
        // Return a promise that resolves when typing is complete
        return new Promise((resolve) => {
            // Scroll to first line only once at the very beginning
            if (messageElement) {
                scrollToFirstLine(messageElement);
            }
            
            // Initialize with empty content
            element.innerHTML = '';
            
            // Parse HTML into segments (tags and text)
            const segments = [];
            let currentIndex = 0;
            
            while (currentIndex < htmlContent.length) {
                if (htmlContent[currentIndex] === '<') {
                    // Find the end of the tag
                    const tagEnd = htmlContent.indexOf('>', currentIndex);
                    if (tagEnd !== -1) {
                        segments.push({
                            type: 'tag',
                            content: htmlContent.substring(currentIndex, tagEnd + 1)
                        });
                        currentIndex = tagEnd + 1;
                    } else {
                        // Malformed tag, treat as text
                        segments.push({
                            type: 'text',
                            content: htmlContent[currentIndex]
                        });
                        currentIndex++;
                    }
                } else {
                    // Collect consecutive text characters
                    let textStart = currentIndex;
                    while (currentIndex < htmlContent.length && htmlContent[currentIndex] !== '<') {
                        currentIndex++;
                    }
                    const text = htmlContent.substring(textStart, currentIndex);
                    if (text) {
                        segments.push({
                            type: 'text',
                            content: text
                        });
                    }
                }
            }
            
            // Type out segments
            let segmentIndex = 0;
            let charIndex = 0;
            const typeSpeed = 10; // milliseconds per character
            let accumulatedHTML = '';
            
            function typeNext() {
                if (segmentIndex >= segments.length) {
                    // Ensure final HTML is set correctly
                    element.innerHTML = htmlContent;
                    // Don't scroll - let user manually scroll through content
                    // Resolve promise when typing is complete
                    resolve();
                    return;
                }
                
                const segment = segments[segmentIndex];
                
                if (segment.type === 'tag') {
                    // Add entire tag at once
                    accumulatedHTML += segment.content;
                    element.innerHTML = accumulatedHTML;
                    segmentIndex++;
                    setTimeout(typeNext, typeSpeed * 2);
                } else {
                    // Type text character by character
                    if (charIndex < segment.content.length) {
                        // Append next character to accumulated HTML
                        accumulatedHTML += segment.content[charIndex];
                        element.innerHTML = accumulatedHTML;
                        charIndex++;
                        setTimeout(typeNext, typeSpeed);
                    } else {
                        // Move to next segment
                        charIndex = 0;
                        segmentIndex++;
                        setTimeout(typeNext, typeSpeed);
                    }
                }
            }
            
            // Start typing
            typeNext();
        });
    }

    function addSuggestions(suggestions, insertAfterElement = null) {
        // If insertAfterElement is provided, add suggestions after that element
        // Otherwise, add before typing indicator (for new messages)
        
        const suggestionsMessage = document.createElement('div');
        suggestionsMessage.className = 'message message-ai';
        suggestionsMessage.classList.add('suggestions-container');
        
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        bubble.style.cssText = 'background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(0, 0, 0, 0.1); padding: 1.25rem;';
        
        const title = document.createElement('div');
        title.style.cssText = 'font-weight: 600; margin-bottom: 1rem; color: rgba(0, 0, 0, 0.7); font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.05em;';
        title.textContent = 'Continue Learning';
        
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'chat-suggestions-buttons';
        buttonsContainer.style.cssText = 'display: flex; flex-direction: column; gap: 0.75rem;';
        
        suggestions.forEach(suggestion => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'chat-suggestion-btn';
            button.textContent = suggestion;
            button.dataset.question = suggestion;
            
            button.addEventListener('click', () => {
                if (questionInput && !questionInput.disabled) {
                    questionInput.value = suggestion;
                    questionInput.style.height = 'auto';
                    questionInput.style.height = Math.min(questionInput.scrollHeight, 120) + 'px';
                    chatForm.dispatchEvent(new Event('submit'));
                }
            });
            
            buttonsContainer.appendChild(button);
        });
        
        bubble.appendChild(title);
        bubble.appendChild(buttonsContainer);
        suggestionsMessage.appendChild(bubble);
        
        if (insertAfterElement) {
            // Insert after the specified element
            insertAfterElement.insertAdjacentElement('afterend', suggestionsMessage);
        } else {
            // For new messages, remove any existing suggestions and add before typing indicator
            const existingSuggestions = document.getElementById('dynamicSuggestions');
            if (existingSuggestions) {
                existingSuggestions.remove();
            }
            suggestionsMessage.id = 'dynamicSuggestions';
            chatMessages.insertBefore(suggestionsMessage, typingIndicator);
        }
    }

    function showTyping() {
        typingIndicator.classList.add('active');
        // Don't auto-scroll - let user manually scroll
        // scrollToBottom();
    }

    function hideTyping() {
        typingIndicator.classList.remove('active');
    }


    function getCsrfToken() {
        const tokenInput = document.querySelector('[name=csrfmiddlewaretoken]');
        if (tokenInput) return tokenInput.value;
        const match = document.cookie.match(new RegExp('(^| )csrftoken=([^;]+)'));
        return match ? match[2] : '';
    }

    // Only set up chat functionality if input box exists (topic is selected)
    if (questionInput && chatForm && sendButton) {
        // Handle Enter key to send (Shift+Enter for new line)
        questionInput.addEventListener('keydown', function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                chatForm.dispatchEvent(new Event('submit'));
            }
        });

        chatForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        const question = questionInput.value.trim();
        if (!question) return;

        questionInput.disabled = true;
        sendButton.disabled = true;

        addMessage(question, true);
        questionInput.value = '';
        questionInput.style.height = 'auto'; // Reset height
        
        // Hide suggestions after first message
        const suggestionsMessage = document.getElementById('suggestionsMessage');
        if (suggestionsMessage) {
            suggestionsMessage.style.display = 'none';
        }
        
        showTyping();

        try {
            // Get selected topic from input dataset (set on page load)
            const selectedTopic = questionInput.dataset.selectedTopic || '';
            
            const response = await fetch("{% url 'module_ask_api' module.id %}", {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCsrfToken()
                },
                body: JSON.stringify({ 
                    question: question,
                    topic: selectedTopic
                })
            });
            const data = await response.json();
            hideTyping();

            if (response.ok && !data.is_error) {
                // Remove any suggestion markers that might have slipped through (safety check)
                const cleanedResponse = removeSuggestionMarkers(data.response);
                
                // Add message with typing effect and wait for it to complete
                const typingPromise = addMessage(cleanedResponse, false);
                
                // Wait for typing to complete, then add suggestions
                if (typingPromise && typeof typingPromise.then === 'function') {
                    typingPromise.then(() => {
                        // Add dynamic suggestions only after typing is completely done
                        if (data.suggestions && data.suggestions.length > 0) {
                            addSuggestions(data.suggestions);
                            // Don't scroll - let user manually scroll through content
                        }
                    });
                } else {
                    // Fallback if promise not returned (user message)
                    if (data.suggestions && data.suggestions.length > 0) {
                        addSuggestions(data.suggestions);
                    }
                }
            } else {
                addMessage(data.response || data.error || 'Sorry, there was an issue. Please try again.', false);
            }
        } catch (error) {
            hideTyping();
            addMessage('Network error. Please try again.', false);
        } finally {
            questionInput.disabled = false;
            sendButton.disabled = false;
            questionInput.focus();
            // Reset textarea height
            questionInput.style.height = 'auto';
        }
    });

        // Auto-resize textarea as user types
        questionInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 120) + 'px';
        });
    }

    function removeSuggestionMarkers(text) {
        // Remove [SUGGESTIONS_START] and [SUGGESTIONS_END] markers and everything between them
        if (!text) return text;
        
        const startMarker = '[SUGGESTIONS_START]';
        const endMarker = '[SUGGESTIONS_END]';
        
        let cleanedText = text;
        
        // Remove all suggestion sections (case-insensitive, handle multiple occurrences)
        let maxIterations = 100; // Safety limit
        let iterations = 0;
        
        while (iterations < maxIterations) {
            // Try case-sensitive first
            let startIdx = cleanedText.indexOf(startMarker);
            let endIdx = cleanedText.indexOf(endMarker);
            
            // If not found, try case-insensitive
            if (startIdx === -1 || endIdx === -1) {
                const textUpper = cleanedText.toUpperCase();
                const startMarkerUpper = startMarker.toUpperCase();
                const endMarkerUpper = endMarker.toUpperCase();
                
                const startIdxUpper = textUpper.indexOf(startMarkerUpper);
                const endIdxUpper = textUpper.indexOf(endMarkerUpper);
                
                if (startIdxUpper !== -1 && endIdxUpper !== -1) {
                    // Find actual case in original text
                    startIdx = cleanedText.toLowerCase().indexOf(startMarker.toLowerCase());
                    endIdx = cleanedText.toLowerCase().indexOf(endMarker.toLowerCase());
                    
                    // If still not found, use uppercase indices
                    if (startIdx === -1) startIdx = startIdxUpper;
                    if (endIdx === -1) endIdx = endIdxUpper;
                }
            }
            
            if (startIdx !== -1 && endIdx !== -1 && startIdx < endIdx) {
                // Remove the entire section including markers
                cleanedText = cleanedText.substring(0, startIdx) + cleanedText.substring(endIdx + endMarker.length);
            } else {
                // No more markers found
                break;
            }
            
            iterations++;
        }
        
        // Also remove any standalone markers that might be left
        cleanedText = cleanedText.replace(/\[SUGGESTIONS_START\]/gi, '');
        cleanedText = cleanedText.replace(/\[SUGGESTIONS_END\]/gi, '');
        
        // Clean up any extra whitespace and newlines
        cleanedText = cleanedText.trim();
        cleanedText = cleanedText.replace(/\n{3,}/g, '\n\n'); // Remove excessive newlines
        
        return cleanedText;
    }

    function getTextFromDataAttribute(elem) {
        // Get the raw attribute value (browser automatically decodes HTML entities in attributes)
        const rawValue = elem.getAttribute('data-response');
        if (!rawValue) return '';
        
        // Return raw value - we'll extract suggestions separately before cleaning
        // The browser already decodes HTML entities from data attributes
        return rawValue;
    }
    
    function getRawTextFromDataAttribute(elem) {
        // Get the raw attribute value without any processing
        const rawValue = elem.getAttribute('data-response');
        return rawValue || '';
    }

    // Handle topic checkbox clicks - switch to topic-specific chat
    function handleTopicCheckboxClick(topicName) {
        // Navigate to the topic-specific chat by reloading the page with topic parameter
        const currentUrl = new URL(window.location.href);
        currentUrl.searchParams.set('topic', encodeURIComponent(topicName));
        window.location.href = currentUrl.toString();
    }

    document.addEventListener('DOMContentLoaded', function () {
        // Store the currently selected topic
        const currentTopic = "{{ selected_topic|escapejs }}";
        
        // Add event listeners to topic checkboxes
        document.querySelectorAll('.topic-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                if (this.checked) {
                    handleTopicCheckboxClick(this.value);
                } else {
                    // If unchecking, navigate back to module page without topic
                    const currentUrl = new URL(window.location.href);
                    currentUrl.searchParams.delete('topic');
                    window.location.href = currentUrl.toString();
                }
            });
        });

        if (suggestionButtons.length > 0 && questionInput && chatForm) {
            suggestionButtons.forEach(button => {
                button.addEventListener('click', () => {
                    if (questionInput.disabled) {
                        return;
                    }
                    const suggestedQuestion = button.dataset.question || '';
                    if (!suggestedQuestion) {
                        return;
                    }
                    questionInput.value = suggestedQuestion;
                    chatForm.dispatchEvent(new Event('submit'));
                });
            });
        }

        
        // Set the current topic in the input dataset for API calls (if input exists)
        if (currentTopic && questionInput) {
            questionInput.dataset.selectedTopic = currentTopic;
        }

        // Function to extract suggestions from response text
        function extractSuggestions(text) {
            if (!text) return { cleanedText: text, suggestions: [] };
            
            const startMarker = '[SUGGESTIONS_START]';
            const endMarker = '[SUGGESTIONS_END]';
            const suggestions = [];
            let cleanedText = text;
            
            // Find markers (case-insensitive)
            let startIdx = -1;
            let endIdx = -1;
            
            // Try case-sensitive first
            startIdx = cleanedText.indexOf(startMarker);
            endIdx = cleanedText.indexOf(endMarker);
            
            // If not found, try case-insensitive
            if (startIdx === -1 || endIdx === -1) {
                const textLower = cleanedText.toLowerCase();
                const startMarkerLower = startMarker.toLowerCase();
                const endMarkerLower = endMarker.toLowerCase();
                
                startIdx = textLower.indexOf(startMarkerLower);
                endIdx = textLower.indexOf(endMarkerLower);
            }
            
            if (startIdx !== -1 && endIdx !== -1 && startIdx < endIdx) {
                // Extract suggestions section
                const suggestionsText = cleanedText.substring(startIdx + startMarker.length, endIdx).trim();
                const rawSuggestions = suggestionsText.split('\n');
                
                for (const s of rawSuggestions) {
                    const cleaned = s.trim();
                    // Skip empty lines, markers, and invalid entries
                    if (cleaned && 
                        cleaned.toLowerCase() !== startMarker.toLowerCase() && 
                        cleaned.toLowerCase() !== endMarker.toLowerCase() &&
                        !cleaned.toLowerCase().startsWith('[suggestions') && 
                        !cleaned.toLowerCase().endsWith(']') &&
                        cleaned.length > 5) {
                        suggestions.push(cleaned);
                    }
                }
                
                // Remove the suggestions section from the response text
                cleanedText = (cleanedText.substring(0, startIdx) + cleanedText.substring(endIdx + endMarker.length)).trim();
            }
            
            // Remove any remaining markers (safety check)
            cleanedText = cleanedText.replace(/\[SUGGESTIONS_START\].*?\[SUGGESTIONS_END\]/gi, '');
            cleanedText = cleanedText.replace(/\[SUGGESTIONS_START\]/gi, '');
            cleanedText = cleanedText.replace(/\[SUGGESTIONS_END\]/gi, '');
            cleanedText = cleanedText.trim();
            
            return { cleanedText, suggestions };
        }

        const historyResponses = document.querySelectorAll('.history-response');
        let lastMessageWithSuggestions = null;
        
        // Process all messages to clean them and find the last one with suggestions
        historyResponses.forEach((elem) => {
            // Get the raw text from the data attribute (before any cleaning)
            const rawText = getRawTextFromDataAttribute(elem);
            if (!rawText) return;
            
            // Extract suggestions from the raw response
            const { cleanedText, suggestions } = extractSuggestions(rawText);
            
            // Process markdown and set the formatted HTML (using cleaned text without suggestions)
            try {
                elem.innerHTML = processMarkdown(cleanedText);
            } catch (error) {
                console.error('Error processing markdown:', error);
                // Fallback: just display the text as-is
                elem.textContent = cleanedText;
            }
            
            // Track the last message with suggestions (most recent one)
            if (suggestions && suggestions.length > 0) {
                const aiMessage = elem.closest('.message.message-ai');
                if (aiMessage) {
                    lastMessageWithSuggestions = { element: aiMessage, suggestions: suggestions };
                }
            }
        });
        
        // Only add suggestions for the most recent message that has suggestions
        if (lastMessageWithSuggestions) {
            const { element: aiMessage, suggestions } = lastMessageWithSuggestions;
            // Check if suggestions already exist after this message (avoid duplicates on page reload)
            const nextSibling = aiMessage.nextElementSibling;
            if (!nextSibling || !nextSibling.classList.contains('suggestions-container')) {
                // Add suggestions right after this AI message
                addSuggestions(suggestions, aiMessage);
            }
        }
        // Don't auto-scroll on page load - show top of chat
        // scrollToBottom();

    });

    // Handle delete memory button
    if (deleteMemoryBtn) {
        deleteMemoryBtn.addEventListener('click', async function() {
            const currentTopic = "{{ selected_topic|escapejs }}";
            
            // Create a more specific confirmation message based on whether a topic is selected
            let confirmMessage;
            if (currentTopic) {
                confirmMessage = `Are you sure you want to delete all conversation history for "${currentTopic}"? This action cannot be undone. Other topic chats will not be affected.`;
            } else {
                confirmMessage = 'Are you sure you want to delete all conversation history for this module? This action cannot be undone.';
            }
            
            if (!confirm(confirmMessage)) {
                return;
            }

            const moduleId = {{ module.id }};
            
            try {
                deleteMemoryBtn.disabled = true;
                deleteMemoryBtn.innerHTML = '<i class="bi bi-hourglass-split me-1"></i>Deleting...';
                
                const response = await fetch(`/modules/${moduleId}/delete-memory/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCsrfToken()
                    },
                    body: JSON.stringify({
                        topic: currentTopic || ''
                    })
                });

                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Clear the chat messages UI
                    const messages = chatMessages.querySelectorAll('.message');
                    messages.forEach(msg => msg.remove());
                    
                    // Show welcome message
                    const welcomeMessage = document.createElement('div');
                    welcomeMessage.className = 'message message-ai';
                    const bubble = document.createElement('div');
                    bubble.className = 'bubble';
                    
                    if (currentTopic) {
                        bubble.innerHTML = `<strong>Welcome to ${currentTopic}!</strong><br><br>This is a dedicated chat for <strong>${currentTopic}</strong> only.<br><br>I'll teach you everything about <strong>${currentTopic}</strong> step by step.<br><br>Use the quick suggestion buttons below or ask your own question to begin.<br><br><strong>Note:</strong> I will only teach <strong>${currentTopic}</strong> in this chat. I won't discuss other topics here.`;
                    } else {
                        bubble.innerHTML = `<strong>Welcome to {{ module.title|escapejs }}!</strong><br><br><strong>Select a topic from the left sidebar to start a dedicated chat.</strong><br><br>Each topic has its own separate chat where I'll teach only that specific topic.<br><br><strong>How it works:</strong><br>• Click on any topic checkbox to open its dedicated chat<br>• Each topic chat is isolated - I'll only teach that topic<br>• You can switch between topics anytime by clicking different checkboxes<br>• Each topic maintains its own conversation history`;
                    }
                    
                    welcomeMessage.appendChild(bubble);
                    chatMessages.insertBefore(welcomeMessage, typingIndicator);
                    
                    // Hide delete button since there's no history now
                    deleteMemoryBtn.style.display = 'none';
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.className = 'message message-ai';
                    const successBubble = document.createElement('div');
                    successBubble.className = 'bubble';
                    successBubble.style.background = 'rgba(34, 197, 94, 0.1)';
                    successBubble.style.border = '1px solid rgba(34, 197, 94, 0.3)';
                    
                    let successMessage;
                    if (currentTopic) {
                        successMessage = `<i class="bi bi-check-circle me-2" style="color: #16a34a;"></i><strong style="color: #16a34a;">Conversation history for "${currentTopic}" deleted successfully!</strong> Other topic chats are unaffected. The AI will start fresh for this topic.`;
                    } else {
                        successMessage = '<i class="bi bi-check-circle me-2" style="color: #16a34a;"></i><strong style="color: #16a34a;">Conversation history deleted successfully!</strong> The AI will start fresh from now on.';
                    }
                    successBubble.innerHTML = successMessage;
                    successMsg.appendChild(successBubble);
                    chatMessages.insertBefore(successMsg, typingIndicator);
                    
                    // Reload page after a short delay to update topic counts
                    setTimeout(() => {
                        window.location.reload();
                    }, 1500);
                } else {
                    alert('Failed to delete conversation history: ' + (data.error || 'Unknown error'));
                    deleteMemoryBtn.disabled = false;
                    deleteMemoryBtn.innerHTML = '<i class="bi bi-trash me-1"></i>Delete Memory';
                }
            } catch (error) {
                console.error('Error deleting memory:', error);
                alert('An error occurred while deleting conversation history. Please try again.');
                deleteMemoryBtn.disabled = false;
                deleteMemoryBtn.innerHTML = '<i class="bi bi-trash me-1"></i>Delete Memory';
            }
        });
    }
</script>
{% endblock extra_js %}
{% endif %}

